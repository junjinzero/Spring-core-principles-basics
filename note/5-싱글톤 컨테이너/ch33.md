## 33강 @Configuration과 싱글톤
- memberService 빈을 만드는 코드를 보면 `memberRepository()` 를 호출한다.
  - 이 메서드를 호출하면 `new MemoryMemberRepository()` 를 호출한다.
- orderService 빈을 만드는 코드도 동일하게 `memberRepository()` 를 호출한다.
  - 이 메서드를 호출하면 `new MemoryMemberRepository()` 를 호출한다.

결과적으로 각각 다른 2개의 `MemoryMemberRepository` 가 생성되면서 싱글톤이 깨지는 것 처럼 보인다.
스프링 컨테이너는 이 문제를 어떻게 해결할까?

[static 이 들어가는 경우 프로그램 시작과 동시에 띄우기 때문에 싱글톤이 보장되지 않음](https://www.inflearn.com/community/questions/1085291/static%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)
```
스프링 프레임워크에서 @Bean 어노테이션이 붙은 메소드는 해당 빈의 생성 로직을 담고 있습니다. 스프링 컨테이너는 이러한 메소드를 호출하여 빈 인스턴스를 생성하고 관리합니다.

일반적인 경우에는 스프링 컨테이너가 @Bean 어노테이션이 붙은 메소드를 자동으로 싱글톤 범위로 관리하여, 해당 빈의 요청이 있을 때마다 이미 생성된 인스턴스를 반환해줍니다. 
즉, 메소드 호출을 통한 빈의 생성과 관리가 스프링 컨테이너 내부의 라이프사이클에 따라 이루어지게 됩니다.

반면, static 메소드는 클래스의 인스턴스가 생성되지 않아도 호출할 수 있는 메소드이며, 클래스 로더가 해당 클래스를 메모리에 로드할 때 메모리에 함께 배치됩니다. 
static 메소드는 특정 인스턴스에 속하지 않기 때문에 스프링 컨테이너가 빈을 관리하는 방식, 즉 인스턴스 레벨에서 처리하는 라이프사이클 관리, 의존성 주입 및 프록시 적용 등과 같은 과정을 거치기 어렵습니다.

그 결과, @Bean 어노테이션을 사용한 static 메소드는 스프링 컨테이너가 반환하는 빈 인스턴스에 대한 싱글톤 보장이 어려워지고, 스프링 컨테이너가 제공하는 기능들을 온전히 사용하지 못하게 됩니다. 
따라서, 일반적으로 @Bean 메소드는 non-static 메소드로 선언하여 스프링 컨테이너가 제어할 수 있게 하는 것이 좋습니다.
```